'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubsetOptions = exports.Subset = exports.SubsetEntry = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _request = require('../request');

var _catalogItem = require('./catalogItem');

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Represents a subset entry.
 */
var SubsetEntry =
/**
 * Create an instance of a subset entry
 * @param {object} [data] The API response data
 * @param {object} [data.item] Item information
 * @param {number} [data.color_id] The color id of the entry item.
 * @param {number} [data.quantity] The number of items in the subset entry.
 * @param {number} [data.extra_quantity] The number of extra items included in the subset.
 * @param {boolean} [data.is_alternate] Indicator that the item is an alternate.
 */
exports.SubsetEntry = function SubsetEntry(data) {
  _classCallCheck(this, SubsetEntry);

  data = data || {};
  /** @type {CatalogItem} */
  this.item = data.item ? new _catalogItem.CatalogItem(data.item) : new _catalogItem.CatalogItem();
  /** @type {number} */
  this.color_id = data.color_id || 0;
  /** @type {number} */
  this.quantity = data.quantity || 0;
  /** @type {number} */
  this.extra_quantity = data.extra_quantity || 0;
  /** @type {boolean} */
  this.is_alternate = data.is_alternate || false;
};
/**
 * Represents a subset item. A subset item can have more than one matching entry due to alternate parts.
 */


var Subset = exports.Subset = function () {
  /**
   * Create an instance of a subset item.
   * @param {object} [data] The response data from API request.
   * @param {number} [data.match_no] The number of matching entries or 0 if there is no matching of alternative item.
   * @param {object} [data.entries] The specific entries for the subset item.
   */
  function Subset(data) {
    _classCallCheck(this, Subset);

    data = data || {};
    /** @type {number} */
    this.match_no = data.match_no || 0;

    var entries = data.entries || [];
    /** @type {SubsetEntry[]} */
    this.entries = entries.map(function (e) {
      return new SubsetEntry(e);
    });
  }
  /**
   * Method to get a subset of a catalog item.
   *
   * Usage:
   *
   * ```
   * var req = Subset.get(ItemType.Set, '6020-1', {break_minifigs: true});
   * client.send(req).then(subset => console.log(subset));
   * ```
   *
   * @param {string} itemType Catalog item type
   * @param {string} itemNumber Catalog item number
   * @param {object} options Options that conform to {@link SubsetOptions}.
   */


  _createClass(Subset, null, [{
    key: 'get',
    value: function get(itemType, itemNumber, options) {
      var method = _request.Request.GET;
      options = options ? new SubsetOptions(options) : new SubsetOptions();

      var uri = '/items/' + itemType + '/' + itemNumber + '/subsets';

      return new _request.Request(method, uri, options, function (data) {
        return data.map(function (e) {
          return new Subset(e);
        });
      });
    }
  }]);

  return Subset;
}();

/**
 * Options that can be used when make a request for a subset.
 */


var SubsetOptions = exports.SubsetOptions = function (_RequestParams) {
  _inherits(SubsetOptions, _RequestParams);

  /**
   * Make an instance of SubsetOptions.
   * @param {object} [data] Raw options object.
   * @param {number} [data.color_id] The color of the item(This value is valid only for {@link ItemType}.Part.
   * @param {boolean} [data.box] Indicates whether the set includes the original box
   * @param {boolean} [data.instruction] Indicates whether the set includes the original instruction
   * @param {boolean} [data.break_minifigs]	Indicates whether the result breaks down minifigs as parts
   * @param {boolean} [data.break_subsets] Indicates whether the result breaks down sets in set
   */
  function SubsetOptions(data) {
    _classCallCheck(this, SubsetOptions);

    var _this = _possibleConstructorReturn(this, (SubsetOptions.__proto__ || Object.getPrototypeOf(SubsetOptions)).call(this, data));

    data = data || {};
    /** @type {number|null} */
    _this.color_id = data.color_id || null;
    /** @type {boolean|null} */
    _this.box = data.box || null;
    /** @type {boolean|null} */
    _this.instruction = data.instruction || null;
    /** @type {boolean|null} */
    _this.break_minifigs = data.break_minifigs || null;
    /** @type {boolean|null} */
    _this.break_subsets = data.break_subsets || null;
    return _this;
  }

  return SubsetOptions;
}(_request.RequestParams);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jYXRhbG9nSXRlbS9zdWJzZXRzLmpzIl0sIm5hbWVzIjpbIlN1YnNldEVudHJ5IiwiZGF0YSIsIml0ZW0iLCJjb2xvcl9pZCIsInF1YW50aXR5IiwiZXh0cmFfcXVhbnRpdHkiLCJpc19hbHRlcm5hdGUiLCJTdWJzZXQiLCJtYXRjaF9ubyIsImVudHJpZXMiLCJtYXAiLCJlIiwiaXRlbVR5cGUiLCJpdGVtTnVtYmVyIiwib3B0aW9ucyIsIm1ldGhvZCIsIkdFVCIsIlN1YnNldE9wdGlvbnMiLCJ1cmkiLCJib3giLCJpbnN0cnVjdGlvbiIsImJyZWFrX21pbmlmaWdzIiwiYnJlYWtfc3Vic2V0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7Ozs7Ozs7O0FBRUE7OztJQUdhQSxXO0FBQ1g7Ozs7Ozs7OztRQURXQSxXLEdBVVgscUJBQVlDLElBQVosRUFBa0I7QUFBQTs7QUFDaEJBLFNBQU9BLFFBQVEsRUFBZjtBQUNBO0FBQ0EsT0FBS0MsSUFBTCxHQUFZRCxLQUFLQyxJQUFMLEdBQVksNkJBQWdCRCxLQUFLQyxJQUFyQixDQUFaLEdBQXlDLDhCQUFyRDtBQUNBO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQkYsS0FBS0UsUUFBTCxJQUFpQixDQUFqQztBQUNBO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQkgsS0FBS0csUUFBTCxJQUFpQixDQUFqQztBQUNBO0FBQ0EsT0FBS0MsY0FBTCxHQUFzQkosS0FBS0ksY0FBTCxJQUF1QixDQUE3QztBQUNBO0FBQ0EsT0FBS0MsWUFBTCxHQUFvQkwsS0FBS0ssWUFBTCxJQUFxQixLQUF6QztBQUNELEM7QUFFSDs7Ozs7SUFHYUMsTSxXQUFBQSxNO0FBQ1g7Ozs7OztBQU1BLGtCQUFZTixJQUFaLEVBQWlCO0FBQUE7O0FBQ2ZBLFdBQU9BLFFBQVEsRUFBZjtBQUNBO0FBQ0EsU0FBS08sUUFBTCxHQUFnQlAsS0FBS08sUUFBTCxJQUFpQixDQUFqQzs7QUFFQSxRQUFJQyxVQUFVUixLQUFLUSxPQUFMLElBQWdCLEVBQTlCO0FBQ0E7QUFDQSxTQUFLQSxPQUFMLEdBQWVBLFFBQVFDLEdBQVIsQ0FBWTtBQUFBLGFBQUssSUFBSVYsV0FBSixDQUFnQlcsQ0FBaEIsQ0FBTDtBQUFBLEtBQVosQ0FBZjtBQUNEO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFjV0MsUSxFQUFVQyxVLEVBQVlDLE8sRUFBUztBQUN4QyxVQUFJQyxTQUFTLGlCQUFRQyxHQUFyQjtBQUNBRixnQkFBVUEsVUFBVSxJQUFJRyxhQUFKLENBQWtCSCxPQUFsQixDQUFWLEdBQXVDLElBQUlHLGFBQUosRUFBakQ7O0FBRUEsVUFBSUMsa0JBQWdCTixRQUFoQixTQUE0QkMsVUFBNUIsYUFBSjs7QUFFQSxhQUFPLHFCQUFZRSxNQUFaLEVBQW9CRyxHQUFwQixFQUF5QkosT0FBekIsRUFBa0MsVUFBQ2IsSUFBRCxFQUFVO0FBQ2pELGVBQU9BLEtBQUtTLEdBQUwsQ0FBVTtBQUFBLGlCQUFLLElBQUlILE1BQUosQ0FBV0ksQ0FBWCxDQUFMO0FBQUEsU0FBVixDQUFQO0FBQ0QsT0FGTSxDQUFQO0FBR0Q7Ozs7OztBQUdIOzs7OztJQUdhTSxhLFdBQUFBLGE7OztBQUNYOzs7Ozs7Ozs7QUFTQSx5QkFBWWhCLElBQVosRUFBaUI7QUFBQTs7QUFBQSw4SEFDVEEsSUFEUzs7QUFFZkEsV0FBT0EsUUFBUSxFQUFmO0FBQ0E7QUFDQSxVQUFLRSxRQUFMLEdBQWdCRixLQUFLRSxRQUFMLElBQWlCLElBQWpDO0FBQ0E7QUFDQSxVQUFLZ0IsR0FBTCxHQUFXbEIsS0FBS2tCLEdBQUwsSUFBWSxJQUF2QjtBQUNBO0FBQ0EsVUFBS0MsV0FBTCxHQUFtQm5CLEtBQUttQixXQUFMLElBQW9CLElBQXZDO0FBQ0E7QUFDQSxVQUFLQyxjQUFMLEdBQXNCcEIsS0FBS29CLGNBQUwsSUFBdUIsSUFBN0M7QUFDQTtBQUNBLFVBQUtDLGFBQUwsR0FBcUJyQixLQUFLcUIsYUFBTCxJQUFzQixJQUEzQztBQVplO0FBYWhCIiwiZmlsZSI6InN1YnNldHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1JlcXVlc3QsIFJlcXVlc3RQYXJhbXN9IGZyb20gJy4uL3JlcXVlc3QnO1xuaW1wb3J0IHtDYXRhbG9nSXRlbX0gZnJvbSAnLi9jYXRhbG9nSXRlbSc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN1YnNldCBlbnRyeS5cbiAqL1xuZXhwb3J0IGNsYXNzIFN1YnNldEVudHJ5e1xuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGEgc3Vic2V0IGVudHJ5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbZGF0YV0gVGhlIEFQSSByZXNwb25zZSBkYXRhXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbZGF0YS5pdGVtXSBJdGVtIGluZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YS5jb2xvcl9pZF0gVGhlIGNvbG9yIGlkIG9mIHRoZSBlbnRyeSBpdGVtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGEucXVhbnRpdHldIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHN1YnNldCBlbnRyeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhLmV4dHJhX3F1YW50aXR5XSBUaGUgbnVtYmVyIG9mIGV4dHJhIGl0ZW1zIGluY2x1ZGVkIGluIHRoZSBzdWJzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RhdGEuaXNfYWx0ZXJuYXRlXSBJbmRpY2F0b3IgdGhhdCB0aGUgaXRlbSBpcyBhbiBhbHRlcm5hdGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgLyoqIEB0eXBlIHtDYXRhbG9nSXRlbX0gKi9cbiAgICB0aGlzLml0ZW0gPSBkYXRhLml0ZW0gPyBuZXcgQ2F0YWxvZ0l0ZW0oZGF0YS5pdGVtKSA6IG5ldyBDYXRhbG9nSXRlbSgpO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuY29sb3JfaWQgPSBkYXRhLmNvbG9yX2lkIHx8IDA7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5xdWFudGl0eSA9IGRhdGEucXVhbnRpdHkgfHwgMDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmV4dHJhX3F1YW50aXR5ID0gZGF0YS5leHRyYV9xdWFudGl0eSB8fCAwO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzX2FsdGVybmF0ZSA9IGRhdGEuaXNfYWx0ZXJuYXRlIHx8IGZhbHNlO1xuICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdWJzZXQgaXRlbS4gQSBzdWJzZXQgaXRlbSBjYW4gaGF2ZSBtb3JlIHRoYW4gb25lIG1hdGNoaW5nIGVudHJ5IGR1ZSB0byBhbHRlcm5hdGUgcGFydHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJzZXR7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYSBzdWJzZXQgaXRlbS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtkYXRhXSBUaGUgcmVzcG9uc2UgZGF0YSBmcm9tIEFQSSByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGEubWF0Y2hfbm9dIFRoZSBudW1iZXIgb2YgbWF0Y2hpbmcgZW50cmllcyBvciAwIGlmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIG9mIGFsdGVybmF0aXZlIGl0ZW0uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbZGF0YS5lbnRyaWVzXSBUaGUgc3BlY2lmaWMgZW50cmllcyBmb3IgdGhlIHN1YnNldCBpdGVtLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSl7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXRjaF9ubyA9IGRhdGEubWF0Y2hfbm8gfHwgMDtcblxuICAgIGxldCBlbnRyaWVzID0gZGF0YS5lbnRyaWVzIHx8IFtdO1xuICAgIC8qKiBAdHlwZSB7U3Vic2V0RW50cnlbXX0gKi9cbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzLm1hcChlID0+IG5ldyBTdWJzZXRFbnRyeShlKSk7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCB0byBnZXQgYSBzdWJzZXQgb2YgYSBjYXRhbG9nIGl0ZW0uXG4gICAqXG4gICAqIFVzYWdlOlxuICAgKlxuICAgKiBgYGBcbiAgICogdmFyIHJlcSA9IFN1YnNldC5nZXQoSXRlbVR5cGUuU2V0LCAnNjAyMC0xJywge2JyZWFrX21pbmlmaWdzOiB0cnVlfSk7XG4gICAqIGNsaWVudC5zZW5kKHJlcSkudGhlbihzdWJzZXQgPT4gY29uc29sZS5sb2coc3Vic2V0KSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaXRlbVR5cGUgQ2F0YWxvZyBpdGVtIHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGl0ZW1OdW1iZXIgQ2F0YWxvZyBpdGVtIG51bWJlclxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb25zIHRoYXQgY29uZm9ybSB0byB7QGxpbmsgU3Vic2V0T3B0aW9uc30uXG4gICAqL1xuICBzdGF0aWMgZ2V0KGl0ZW1UeXBlLCBpdGVtTnVtYmVyLCBvcHRpb25zKSB7XG4gICAgbGV0IG1ldGhvZCA9IFJlcXVlc3QuR0VUO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gbmV3IFN1YnNldE9wdGlvbnMob3B0aW9ucykgOiBuZXcgU3Vic2V0T3B0aW9ucygpO1xuXG4gICAgbGV0IHVyaSA9IGAvaXRlbXMvJHtpdGVtVHlwZX0vJHtpdGVtTnVtYmVyfS9zdWJzZXRzYDtcblxuICAgIHJldHVybiBuZXcgUmVxdWVzdChtZXRob2QsIHVyaSwgb3B0aW9ucywgKGRhdGEpID0+IHtcbiAgICAgIHJldHVybiBkYXRhLm1hcCggZSA9PiBuZXcgU3Vic2V0KGUpICk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgd2hlbiBtYWtlIGEgcmVxdWVzdCBmb3IgYSBzdWJzZXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJzZXRPcHRpb25zIGV4dGVuZHMgUmVxdWVzdFBhcmFtcyB7XG4gIC8qKlxuICAgKiBNYWtlIGFuIGluc3RhbmNlIG9mIFN1YnNldE9wdGlvbnMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbZGF0YV0gUmF3IG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGEuY29sb3JfaWRdIFRoZSBjb2xvciBvZiB0aGUgaXRlbShUaGlzIHZhbHVlIGlzIHZhbGlkIG9ubHkgZm9yIHtAbGluayBJdGVtVHlwZX0uUGFydC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZGF0YS5ib3hdIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzZXQgaW5jbHVkZXMgdGhlIG9yaWdpbmFsIGJveFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXRhLmluc3RydWN0aW9uXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc2V0IGluY2x1ZGVzIHRoZSBvcmlnaW5hbCBpbnN0cnVjdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXRhLmJyZWFrX21pbmlmaWdzXVx0SW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJlc3VsdCBicmVha3MgZG93biBtaW5pZmlncyBhcyBwYXJ0c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXRhLmJyZWFrX3N1YnNldHNdIEluZGljYXRlcyB3aGV0aGVyIHRoZSByZXN1bHQgYnJlYWtzIGRvd24gc2V0cyBpbiBzZXRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEpe1xuICAgIHN1cGVyKGRhdGEpO1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfG51bGx9ICovXG4gICAgdGhpcy5jb2xvcl9pZCA9IGRhdGEuY29sb3JfaWQgfHwgbnVsbDtcbiAgICAvKiogQHR5cGUge2Jvb2xlYW58bnVsbH0gKi9cbiAgICB0aGlzLmJveCA9IGRhdGEuYm94IHx8IG51bGw7XG4gICAgLyoqIEB0eXBlIHtib29sZWFufG51bGx9ICovXG4gICAgdGhpcy5pbnN0cnVjdGlvbiA9IGRhdGEuaW5zdHJ1Y3Rpb24gfHwgbnVsbDtcbiAgICAvKiogQHR5cGUge2Jvb2xlYW58bnVsbH0gKi9cbiAgICB0aGlzLmJyZWFrX21pbmlmaWdzID0gZGF0YS5icmVha19taW5pZmlncyB8fCBudWxsO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbnxudWxsfSAqL1xuICAgIHRoaXMuYnJlYWtfc3Vic2V0cyA9IGRhdGEuYnJlYWtfc3Vic2V0cyB8fCBudWxsO1xuICB9XG59XG4iXX0=